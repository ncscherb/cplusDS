 // bo7-1.cpp ???????(??????)??(??????c7-1.h????)?????????(21??)????????7.1??
 // 7.2????7.4??7.6
 int LocateVex(MGraph G,VertexType u)
 { // ??????????G?????u??G??????????????
   // ???????????G????????u?????ö??????????ã??????-1
   int i;
   for(i=0;i<G.vexnum;++i)
     if(strcmp(u,G.vexs[i])==0)
       return i;
   return -1;
 }

 void CreateFUDG(MGraph &G)
 { // ????????(??????)????????????????û???????????????G
   int i,j,k;
   char filename[13];
   VertexType va,vb;
   FILE *graphlist;
   printf("???????????????(f7-1.txt??f7-2.txt)??");
   scanf("%s",filename);
   graphlist=fopen(filename,"r"); // ???????????????graphlist???
   fscanf(graphlist,"%d",&G.vexnum);
   fscanf(graphlist,"%d",&G.arcnum);
   for(i=0;i<G.vexnum;++i) // ??????????
     fscanf(graphlist,"%s",G.vexs[i]);
   for(i=0;i<G.vexnum;++i) // ???????????
     for(j=0;j<G.vexnum;++j)
     {
       G.arcs[i][j].adj=0; // ?
       G.arcs[i][j].info=NULL; // û????????
     }
   for(k=0;k<G.arcnum;++k)
   {
     fscanf(graphlist,"%s%s",va,vb);
     i=LocateVex(G,va);
     j=LocateVex(G,vb);
     G.arcs[i][j].adj=G.arcs[j][i].adj=1; // ?????
   }
   fclose(graphlist); // ??????????
   G.kind=UDG;
 }

 void CreateFUDN(MGraph &G)
 { // ????????(??????)????????????????û????????????????G
   int i,j,k,w;
   char filename[13];
   VertexType va,vb;
   FILE *graphlist;
   printf("?????????????????");
   scanf("%s",filename);
   graphlist=fopen(filename,"r"); // ???????????????graphlist???
   fscanf(graphlist,"%d",&G.vexnum);
   fscanf(graphlist,"%d",&G.arcnum);
   for(i=0;i<G.vexnum;++i) // ??????????
     fscanf(graphlist,"%s",G.vexs[i]);
   for(i=0;i<G.vexnum;++i) // ???????????
     for(j=0;j<G.vexnum;++j)
     {
       G.arcs[i][j].adj=INFINITY; // ??
       G.arcs[i][j].info=NULL; // û????????
     }
   for(k=0;k<G.arcnum;++k)
   {
     fscanf(graphlist,"%s%s%d",va,vb,&w);
     i=LocateVex(G,va);
     j=LocateVex(G,vb);
     G.arcs[i][j].adj=G.arcs[j][i].adj=w; // ??????
   }
   fclose(graphlist); // ??????????
   G.kind=UDN;
 }

 void CreateDG(MGraph &G)
 { // ????????(??????)????????????????G
   int i,j,k,l,IncInfo;
   char s[MAX_INFO];
   VertexType va,vb;
   printf("???????????G???????,????,????????????(??:1,??:0): ");
   scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
   printf("??????%d????????(<%d?????):\n",G.vexnum,MAX_NAME);
   for(i=0;i<G.vexnum;++i) // ??????????
     scanf("%s",G.vexs[i]);
   for(i=0;i<G.vexnum;++i) // ???????????
     for(j=0;j<G.vexnum;++j)
     {
       G.arcs[i][j].adj=0; // ?
       G.arcs[i][j].info=NULL;
     }
   printf("??????%d???????? ???(??????????): \n",G.arcnum);
   for(k=0;k<G.arcnum;++k)
   {
     scanf("%s%s%*c",va,vb);  // %*c????????
     i=LocateVex(G,va);
     j=LocateVex(G,vb);
     G.arcs[i][j].adj=1; // ?????
     if(IncInfo)
     {
       printf("??????û?????????(<%d?????): ",MAX_INFO);
       gets(s);
       l=strlen(s);
       if(l)
       {
         G.arcs[i][j].info=(char*)malloc((l+1)*sizeof(char)); // ????
         strcpy(G.arcs[i][j].info,s);
       }
     }
   }
   G.kind=DG;
 }

 void CreateDN(MGraph &G)
 { // ????????(??????)?????????????????G
   int i,j,k,w,IncInfo;
   char s[MAX_INFO];
   VertexType va,vb;
   printf("????????????G???????,????,????????????(??:1,??:0): ");
   scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
   printf("??????%d????????(<%d?????):\n",G.vexnum,MAX_NAME);
   for(i=0;i<G.vexnum;++i) // ??????????
     scanf("%s",G.vexs[i]);
   for(i=0;i<G.vexnum;++i) // ???????????
     for(j=0;j<G.vexnum;++j)
     {
       G.arcs[i][j].adj=INFINITY; // ??
       G.arcs[i][j].info=NULL;
     }
   printf("??????%d???????? ??? ??(??????????): \n",G.arcnum);
   for(k=0;k<G.arcnum;++k)
   {
     scanf("%s%s%d%*c",va,vb,&w);  // %*c????????
     i=LocateVex(G,va);
     j=LocateVex(G,vb);
     G.arcs[i][j].adj=w; // ??????
     if(IncInfo)
     {
       printf("??????û?????????(<%d?????): ",MAX_INFO);
       gets(s);
       w=strlen(s);
       if(w)
       {
         G.arcs[i][j].info=(char*)malloc((w+1)*sizeof(char)); // ????
         strcpy(G.arcs[i][j].info,s);
       }
     }
   }
   G.kind=DN;
 }

 void CreateUDG(MGraph &G)
 { // ????????(??????)????????????????G
   int i,j,k,l,IncInfo;
   char s[MAX_INFO];
   VertexType va,vb;
   printf("???????????G???????,????,????????????(??:1,??:0): ");
   scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
   printf("??????%d????????(<%d?????):\n",G.vexnum,MAX_NAME);
   for(i=0;i<G.vexnum;++i) // ??????????
     scanf("%s",G.vexs[i]);
   for(i=0;i<G.vexnum;++i) // ???????????
     for(j=0;j<G.vexnum;++j)
     {
       G.arcs[i][j].adj=0; // ?
       G.arcs[i][j].info=NULL;
     }
   printf("??????%d????????1 ????2(??????????): \n",G.arcnum);
   for(k=0;k<G.arcnum;++k)
   {
     scanf("%s%s%*c",va,vb); // %*c????????
     i=LocateVex(G,va);
     j=LocateVex(G,vb);
     G.arcs[i][j].adj=G.arcs[j][i].adj=1; // ?????
     if(IncInfo)
     {
       printf("??????ñ????????(<%d?????): ",MAX_INFO);
       gets(s);
       l=strlen(s);
       if(l)
       {
         G.arcs[i][j].info=G.arcs[j][i].info=(char*)malloc((l+1)*sizeof(char));
	 // ?????????????????????
	 strcpy(G.arcs[i][j].info,s);
       }
     }
   }
   G.kind=UDG;
 }

 void CreateUDN(MGraph &G)
 { // ????????(??????)?????????????????G????7.2
   int i,j,k,w,IncInfo;
   char s[MAX_INFO];
   VertexType va,vb;
   printf("????????????G???????,????,????????????(??:1,??:0): ");
   scanf("%d,%d,%d",&G.vexnum,&G.arcnum,&IncInfo);
   printf("??????%d????????(<%d?????):\n",G.vexnum,MAX_NAME);
   for(i=0;i<G.vexnum;++i) // ??????????
     scanf("%s",G.vexs[i]);
   for(i=0;i<G.vexnum;++i) // ???????????
     for(j=0;j<G.vexnum;++j)
     {
       G.arcs[i][j].adj=INFINITY; // ??
       G.arcs[i][j].info=NULL;
     }
   printf("??????%d????????1 ????2 ??(??????????): \n",G.arcnum);
   for(k=0;k<G.arcnum;++k)
   {
     scanf("%s%s%d%*c",va,vb,&w); // %*c????????
     i=LocateVex(G,va);
     j=LocateVex(G,vb);
     G.arcs[i][j].adj=G.arcs[j][i].adj=w; // ????
     if(IncInfo)
     {
       printf("??????ñ????????(<%d?????): ",MAX_INFO);
       gets(s);
       w=strlen(s);
       if(w)
       {
         G.arcs[i][j].info=G.arcs[j][i].info=(char*)malloc((w+1)*sizeof(char));
         // ?????????????????????
         strcpy(G.arcs[i][j].info,s);
       }
     }
   }
   G.kind=UDN;
 }

 void CreateGraph(MGraph &G)
 { // ????????(??????)????????????G????7.1??
   printf("???????G??????(?????:0,??????:1,?????:2,??????:3): ");
   scanf("%d",&G.kind);
   switch(G.kind)
   {
     case DG: CreateDG(G); // ?????????
              break;
     case DN: CreateDN(G); // ??????????
              break;
     case UDG:CreateUDG(G); // ?????????
              break;
     case UDN:CreateUDN(G); // ??????????
   }
 }

 void DestroyGraph(MGraph &G)
 { // ??????????G???????????????????G
   int i,j,k=0;
   if(G.kind%2) // ??
     k=INFINITY; // k??????????????????????????
   for(i=0;i<G.vexnum;i++) // ??????????????(???????)
     if(G.kind<2) // ????
     {
       for(j=0;j<G.vexnum;j++)
         if(G.arcs[i][j].adj!=k) // ???
           if(G.arcs[i][j].info) // ????????
           {
             free(G.arcs[i][j].info);
             G.arcs[i][j].info=NULL;
           }
     } // ???????????if-else?????
     else // ????
       for(j=i+1;j<G.vexnum;j++) // ?????????
         if(G.arcs[i][j].adj!=k) // ???
           if(G.arcs[i][j].info) // ????????
	   {
             free(G.arcs[i][j].info);
             G.arcs[i][j].info=G.arcs[j][i].info=NULL;
           }
   G.vexnum=0; // ???????0
   G.arcnum=0; // ?????0
 }

 VertexType& GetVex(MGraph G,int v)
 { // ??????????G?????v??G???????????????????????????v???
   if(v>=G.vexnum||v<0)
     exit(ERROR);
   return G.vexs[v];
 }

 Status PutVex(MGraph &G,VertexType v,VertexType value)
 { // ??????????G?????v??G????????????????????v?????value
   int k;
   k=LocateVex(G,v); // k?????v???G??????
   if(k<0)
     return ERROR;
   strcpy(G.vexs[k],value);
   return OK;
 }

 int FirstAdjVex(MGraph G,VertexType v)
 { // ??????????G?????v??G?????????
   // ?????????????v?????????????????????????G??û???????????-1
   int i,j=0,k;
   k=LocateVex(G,v); // k?????v???G??????
   if(G.kind%2) // ??
     j=INFINITY;
   for(i=0;i<G.vexnum;i++)
     if(G.arcs[k][i].adj!=j)
       return i;
   return -1;
 }

 int NextAdjVex(MGraph G,VertexType v,VertexType w)
 { // ??????????G?????v??G?????????w??v????????
   // ?????????????v??(?????w??)??????????????????w??v?????????????????-1
   int i,j=0,k1,k2;
   k1=LocateVex(G,v); // k1?????v???G??????
   k2=LocateVex(G,w); // k2?????w???G??????
   if(G.kind%2) // ??
     j=INFINITY;
   for(i=k2+1;i<G.vexnum;i++)
     if(G.arcs[k1][i].adj!=j)
       return i;
   return -1;
 }

 void InsertVex(MGraph &G,VertexType v)
 { // ??????????G?????v???G??????????????
   // ????????????G???????¶???v(?????????????????????InsertArc()???)
   int i,j=0;
   if(G.kind%2) // ??
     j=INFINITY;
   strcpy(G.vexs[G.vexnum],v); // ?????¶???????
   for(i=0;i<=G.vexnum;i++)
   {
     G.arcs[G.vexnum][i].adj=G.arcs[i][G.vexnum].adj=j;
     // ??????????????????????????(????)
     G.arcs[G.vexnum][i].info=G.arcs[i][G.vexnum].info=NULL; // ??????????????
   }
   G.vexnum++; // ?G?????????1
 }

 Status DeleteVex(MGraph &G,VertexType v)
 { // ??????????G?????v??G?????????????????????G?????v?????????
   int i,j,k;
   VRType m=0;
   if(G.kind%2) // ??
     m=INFINITY;
   k=LocateVex(G,v); // k??????????v?????
   if(k<0) // v?????G?????
     return ERROR;
   for(j=0;j<G.vexnum;j++)
     if(G.arcs[j][k].adj!=m) // ???????
     {
       if(G.arcs[j][k].info) // ????????
         free(G.arcs[j][k].info); // ?????????
       G.arcnum--; // ??????
     }
   if(G.kind<2) // ????
     for(j=0;j<G.vexnum;j++)
       if(G.arcs[k][j].adj!=m) // ?????
       {
	 if(G.arcs[k][j].info) // ????????
           free(G.arcs[k][j].info); // ?????????
         G.arcnum--; // ??????
       }
   for(j=k+1;j<G.vexnum;j++) // ???k???????????????????
     strcpy(G.vexs[j-1],G.vexs[j]);
   for(i=0;i<G.vexnum;i++)
     for(j=k+1;j<G.vexnum;j++)
       G.arcs[i][j-1]=G.arcs[i][j]; // ??????????????????????
   for(i=0;i<G.vexnum;i++)
     for(j=k+1;j<G.vexnum;j++)
       G.arcs[j-1][i]=G.arcs[j][i]; // ??????????????µ???????
   G.vexnum--; // ????????????
   return OK;
 }

 Status InsertArc(MGraph &G,VertexType v,VertexType w)
 { // ??????????G?????v??w??G??????????
   // ???????????G??????<v,w>????G?????????????????<w,v>
   int i,l,v1,w1;
   char s[MAX_INFO];
   v1=LocateVex(G,v); // ?
   w1=LocateVex(G,w); // ?
   if(v1<0||w1<0)
     return ERROR;
   G.arcnum++; // ?????????1
   if(G.kind%2) // ??
   {
     printf("??????????????: ");
     scanf("%d",&G.arcs[v1][w1].adj);
   }
   else // ?
     G.arcs[v1][w1].adj=1;
   printf("?????û???????????(0:?? 1:??): ");
   scanf("%d%*c",&i);
   if(i)
   {
     printf("??????û???????????(<%d?????)??",MAX_INFO);
     gets(s);
     l=strlen(s);
     if(l)
     {
       G.arcs[v1][w1].info=(char*)malloc((l+1)*sizeof(char));
       strcpy(G.arcs[v1][w1].info,s);
     }
   }
   if(G.kind>1) // ????
   {
     G.arcs[w1][v1].adj=G.arcs[v1][w1].adj;
     G.arcs[w1][v1].info=G.arcs[v1][w1].info; // ?????????????
   }
   return OK;
 }

 Status DeleteArc(MGraph &G,VertexType v,VertexType w)
 { // ??????????G?????v??w??G??????????
   // ???????????G???????<v,w>????G?????????????????<w,v>
   int v1,w1,j=0;
   if(G.kind%2) // ??
     j=INFINITY;
   v1=LocateVex(G,v); // ?
   w1=LocateVex(G,w); // ?
   if(v1<0||w1<0) // v1??w1????????
     return ERROR;
   G.arcs[v1][w1].adj=j;
   if(G.arcs[v1][w1].info) // ?????????
   {
     free(G.arcs[v1][w1].info);
     G.arcs[v1][w1].info=NULL;
   }
   if(G.kind>=2) // ???????????<w,v>
   {
     G.arcs[w1][v1].adj=j;
     G.arcs[w1][v1].info=NULL;
   }
   G.arcnum--; // ????-1
   return OK;
 }

 Boolean visited[MAX_VERTEX_NUM]; // ??????????(?????)
 void(*VisitFunc)(VertexType); // ????????
 void DFS(MGraph G,int v)
 { // ???v????????????????????????G????7.5
   int w;
   visited[v]=TRUE; // ???÷??????TRUE(?????)
   VisitFunc(G.vexs[v]); // ?????v??????
   for(w=FirstAdjVex(G,G.vexs[v]);w>=0;w=NextAdjVex(G,G.vexs[v],G.vexs[w]))
     if(!visited[w])
       DFS(G,w); // ??v??????????????w?????????????DFS
 }

 void DFSTraverse(MGraph G,void(*Visit)(VertexType))
 { // ??????????G?????Visit????????ú???????7.4
   // ????????????1???????????????????G??????ÿ????????ú???Visit?????????
   int v;
   VisitFunc=Visit; // ?????????VisitFunc???DFS??????????????
   for(v=0;v<G.vexnum;v++)
     visited[v]=FALSE; // ??????????????(???????)
   for(v=0;v<G.vexnum;v++)
     if(!visited[v])
       DFS(G,v); // ?????????????v????DFS
   printf("\n");
 }

 typedef VRType QElemType; // ???????????
 #include"c3-2.h" // ??????????BFSTraverse()??
 #include"bo3-2.cpp" // ????????????????BFSTraverse()??
 void BFSTraverse(MGraph G,void(*Visit)(VertexType))
 { // ??????????G?????Visit????????ú???????7.6
   // ????????????1???????????????????????G,????ÿ????????ú???Visit?????????
   int v,u,w;
   LinkQueue Q; // ??ø???????Q???????????visited
   for(v=0;v<G.vexnum;v++)
     visited[v]=FALSE; // ?ó??
   InitQueue(Q); // ?ÿ?????????Q
   for(v=0;v<G.vexnum;v++)
     if(!visited[v]) // v???????
     {
       visited[v]=TRUE; // ???÷??????TRUE(?????)
       Visit(G.vexs[v]);
       EnQueue(Q,v); // v?????
       while(!QueueEmpty(Q)) // ???????
       {
	 DeQueue(Q,u); // ?????????????u
	 for(w=FirstAdjVex(G,G.vexs[u]);w>=0;w=NextAdjVex(G,G.vexs[u],G.vexs[w]))
	   if(!visited[w]) // w?u????????????????????
           {
             visited[w]=TRUE;
             Visit(G.vexs[w]);
             EnQueue(Q,w);
           }
       }
     }
   printf("\n");
 }

 void Display(MGraph G)
 { // ????????????????G
   int i,j;
   char s[7];
   switch(G.kind)
   {
     case DG: strcpy(s,"?????");
              break;
     case DN: strcpy(s,"??????");
              break;
     case UDG:strcpy(s,"?????");
              break;
     case UDN:strcpy(s,"??????");
   }
   printf("%d??????%d??????%s????????????: ",G.vexnum,G.arcnum,s);
   for(i=0;i<G.vexnum;++i) // ???G.vexs
     printf("%s ",G.vexs[i]);
   printf("\nG.arcs.adj:\n"); // ???G.arcs.adj
   for(i=0;i<G.vexnum;i++)
   {
     for(j=0;j<G.vexnum;j++)
       printf("%11d",G.arcs[i][j].adj);
     printf("\n");
   }
   printf("G.arcs.info:\n"); // ???G.arcs.info
   printf("????1(???) ????2(???) ?ñ????????\n");
   for(i=0;i<G.vexnum;i++)
     if(G.kind<2) // ????
     {
       for(j=0;j<G.vexnum;j++)
         if(G.arcs[i][j].info)
           printf("%5s %11s     %s\n",G.vexs[i],G.vexs[j],G.arcs[i][j].info);
     } // ???????????if-else?????
     else // ????,?????????
       for(j=i+1;j<G.vexnum;j++)
         if(G.arcs[i][j].info)
           printf("%5s %11s     %s\n",G.vexs[i],G.vexs[j],G.arcs[i][j].info);
 }